这是文档 **第 125-135 页** 的翻译内容，涵盖了 **5.6 模块转换器 API (Module Transformer API)** 和 **5.7 变体处理 (Variant handling)** 的大部分内容（直至 5.7.9.3 代码生成器）。

---

### 5.6. 模块转换器 API (Module Transformer API)

#### 5.6.1. 目的 (Purpose)

模块转换器用于将现有的模块配置转换为另一个版本或目标/派生型号。例如，如果您有一个 AUTOSAR 2.1 的配置项目，并希望将其导入到 AUTOSAR 3.0 项目中，则会调用特定于模块的转换器将配置转换为新版本。

#### 5.6.2. API

如果您从 EB tresos Studio 的 `tools` 文件夹安装了 eclipse 工具，则可以在 Eclipse 的帮助内容中找到 DCtxt（数据模型公共 API）的文档，标题为 **Public API Java Documentation**。如果您将 EB tresos Studio 设置为目标平台，该帮助也可以作为 javadoc 在 Java Eclipse 编辑器中使用。

#### 5.6.3. 注册模块转换器 (Registering a module transformer)

要注册模块转换器，必须在新模块的 `plugin.xml` 中注册 `dreisoft.tresos.launcher2.api.plugin.moduletransformer` 扩展点。

**步骤如下：**

1. 通过 `plugin.xml` 编辑器添加扩展点。
2. 输入它所属模块的 `moduleId`，并为转换器分配一个 `id`。
* 例如，如果模块 ID 是 `MyModule_TS_T16D4M2I1R0`，则转换器 ID 可以是 `MyModuleTransformer_TS_T16D4M2I1R0`。
* `moduleId` 指定了旧配置将要转换到的**目标模块**。
* 源模块的版本可以在 `enablement` 属性中指定（见下文）。


3. 向 `moduletransformer` 添加名为 **`type`** 的子元素。
* 输入转换器的质量类型：`fully` (完全), `partially` (部分), `fallback` (回退)。
* 优先级规则：`fully` 优于 `partially`，`partially` 优于 `fallback`。


4. 向 `moduletransformer` 添加名为 **`transformer`** 的子元素。
* 此元素定义执行转换的类。该类必须实现 `dreisoft.tresos.launcher2.module.transform.IModuleTransformer`。
* 为了支持扩展点的全部功能，它必须继承 `dreisoft.tresos.launcher2.module.transform.AbstractModuleTransformer`。
* 点击 `class:` 链接将打开类创建向导，并已自动添加了正确的抽象类。


5. 向 `moduletransformer` 添加名为 **`transformation`** 的子元素。
* 输入将执行的转换类型。可能的转换是 `"version"`（版本转换）或 `"target"`（目标转换）。


6. 向 `moduletransformer` 添加名为 **`enablement`** 的子元素。
* 在 `enablement` 中，您可以输入表达式来查询模块的某些变量并将其与您输入的值进行比较。如果表达式计算结果为 `true`，则该转换器将为此模块启用。
* **可使用的变量包括：**
* `id`: 模块 ID (例如 `PduR_TS_T16D4M2I0R0`)
* `type`: 模块类型 (例如 `PduR`)
* `category`: 模块类别 (例如 `Com`)
* `layer`: 模块层 (例如 `Service`)
* `relVersion`: 发布版本 (例如 `2.1.1`, `2.1` = `2.1.*`, `2` = `2.*` = `2.*.*`)
* `specVersion`: 模块规范版本 (格式同上)
* `swVersion`: 模块软件版本 (格式同上)
* `ecuTypes`: 支持的目标/派生型号 (例如 `V850/V850EGP1`, `V850`, `S12X`)





##### 5.6.3.1. 示例 (Examples)

**Enablement 表达式示例：**

```xml
<enablement>
  <and>
    <with variable="ecuTypes"><iterate value="V850"/></with>
    <with variable="relVersion"><equals value="2.0.*"/></with>
  </and>
</enablement>

```

**注册模块转换器的完整示例：**
此示例注册了一个模块转换器，将名为 `MyModule` 的模块从版本 2.0 转换为 2.1。

```xml
<extension id="MyModuleTransformerExtId" point="dreisoft.tresos.launcher2.api.plugin.moduletransformer">
  <moduletransformer id="MyModuleTransformer_TS_T16D4M2I1R0" moduleId="MyModule_TS_T16D4M2I1R0">
    <type value="partially"/>
    <transformation type="version"/>
    <enablement>
      <and>
        <with variable="type"><equals value="MyModule"/></with>
        <with variable="relVersion"><equals value="2.0"/></with>
      </and>
    </enablement>
    <transformer class="eb.autocore.mymodule.transformer.Rel20Transformer"/>
  </moduletransformer>
</extension>

```

#### 5.6.4. 实现模块转换器类 (Implementing a module transformer Class)

如果您遵循了上一节的步骤，您应该拥有一个扩展了 `AbstractModuleTransformer` 的 Java 类。您唯一需要实现的抽象方法是：

```java
public boolean doTransform(
    ModuleDescription sourceModule,
    ModuleDescription targetModule,
    DCtxt moduleConfiguration
)

```

这些参数将允许您访问相关信息以执行转换。

---

### 5.7. 变体处理和构建后加载支持 (Variant handling and post-build loadable support)

#### 5.7.1. 目的 (Purpose)

本章描述了如何在 EB tresos Studio 中启用变体处理（Variant handling）。

#### 5.7.2. 先决条件 (Prerequisites)

要使用变体处理功能，您需要有效的 Feature-license（功能许可证）。

#### 5.7.3. 支持变体选择的模块 (Module with support for variant selection)

为了支持变体处理，模块必须在其参数定义中包含 `IMPLEMENTATION_CONFIG_VARIANT` 参数。此参数通常在 AUTOSAR 标准模块定义 (StMD) 中定义。
供应商特定模块定义 (VsMD) 必须限制允许的变体范围（参见 5.4.1.2 节“配置变体”）。

如果模块支持 **PostBuildSelectable**（构建后可由选择）变体，则该模块必须包含 `PREDEFINED_VARIANTS` 容器。

#### 5.7.4. 将元素标记为构建后可选择变体感知 (Marking elements as post-build selectable variant aware)

要使某个配置参数具有“变体感知能力”（即可以为不同的变体配置不同的值），必须在参数定义的 Schema 节点中将属性 `POSTBUILD-VARIANT-MULTIPLICITY` 设置为 `true`。

```xml
<v:var name="MyParam" type="INTEGER">
    <a:a name="POSTBUILD-VARIANT-MULTIPLICITY" value="true"/>
</v:var>

```

当此属性设置为 `true` 时，如果用户选择了 `PredefinedVariant`，GUI 将允许为该参数配置多个值（每个预定义变体一个值）。

#### 5.7.5. AUTOSAR 属性 postBuildVariantUsed

AUTOSAR 定义了一个属性 `postBuildVariantUsed`，用于指示某个参数是否实际上使用了构建后变体功能。在 EB tresos Studio 中，这通常是自动处理的，但在某些情况下，您可能需要手动检查或设置相关属性。

#### 5.7.6. 将元素标记为构建后加载变体感知 (Marking elements as post-build loadable variant-aware)

类似于构建后可选择（selectable），构建后可加载（loadable）也允许在构建后阶段更改配置，但机制略有不同（通常涉及重新加载配置数据而无需重新编译代码）。在 XDM 中标记元素的方式类似，但通常涉及特定的配置类设置 (`PostBuildLoadable`)。

#### 5.7.7. 变体处理 API (Variant handling API)

EB tresos Studio 提供了一套 Java API 来访问和操作变体信息。这包括：

* 查询当前活动的变体。
* 获取所有已定义的预定义变体。
* 检查某个节点是否具有变体条件。

这些 API 可以在自定义编辑器、生成器或验证规则中使用。

#### 5.7.8. 变体感知的代码生成器 (Variant-aware code generators)

为了支持变体，代码生成器必须能够处理多个配置集。

* **非变体感知生成器**：对所有变体只运行一次（通常使用默认或公共配置）。
* **变体感知生成器**：可以为每个变体运行一次，生成特定于变体的代码或数据结构。

在注册生成器时，可以通过设置参数 `variantAware` 为 `true` 来将其标记为变体感知（见 5.7.9.3 节）。

#### 5.7.9. 变体处理演示插件 (Variant handling demo plug-in)

EB tresos Studio 提供了一个名为 `EcuC_VariantsDemo` 的演示插件，展示了如何实现变体处理。该演示位于 `demos/Studio/` 目录下。

**该演示包含：**

1. **EcuC 模块**：定义了变体（`PredefinedVariants`）。
2. **Variant 模块**：包含变体感知的参数。
3. **代码生成器**：展示了如何生成支持变体的代码。

##### 5.7.9.1. EcuC 模块 (The EcuC module)

`EcuC` 模块是变体处理的核心，因为它包含 `EcucPostBuildVariants` 容器，其中定义了所有的 `PredefinedVariants`（预定义变体）。

在演示中，EcuC 模块配置了两个预定义变体：

* `Variant_A`
* `Variant_B`

##### 5.7.9.2. Variant 模块 (The variant module)

演示中的 `VariantModule` 包含几个参数，这些参数被标记为 `POSTBUILD-VARIANT-MULTIPLICITY = true`。
在 GUI 中，当启用变体视图时，用户可以为 `Variant_A` 和 `Variant_B` 分别设置这些参数的值。

##### 5.7.9.3. 代码生成器 (The code generators)

演示插件注册了两个代码生成器来展示不同的处理方式：

1. **非变体感知生成器 (Non-variant aware generator)**：
* 只运行一次。
* 生成包含所有变体公共部分的代码，或者生成负责在运行时选择正确配置及其数据的调度代码。


2. **变体感知生成器 (Variant aware generator)**：
* **注册方式**：在 `plugin.xml` 的生成器扩展点中添加参数：
```xml
<parameter name="variantAware" value="true"/>

```


* **行为**：该生成器会**为每个配置的变体运行一次**。
* **上下文**：在每次运行中，数据模型（DataModel）会自动呈现为该特定变体的视图（即 `value()` 方法返回该变体的值）。



---

**（第 125-135 页翻译结束）**

接下来的内容（第 136 页起）将继续介绍：

* **5.7.9.4. 切换变体 (Switching variants)**：如何在 GUI 中切换视图。
* **5.7.9.5. 管理变体 (Managing variants)**。
* **5.8. 通过多重配置容器支持构建后加载 (Post-build loadable support via Multiple Configuration Containers)**。

**是否继续翻译后续页面？**