这是文档 **第 241-250 页** 的翻译内容。

这一部分主要介绍了 **基于模板的代码生成器 API (Template-based Code Generator API)**，它是 EB tresos Studio 中最常用的代码生成方式，详细讲解了如何在模板文件中使用各种指令（如循环、条件判断、变量、宏等）来动态生成代码。

---

### 7.2. 基于模板的代码生成器 API (Template-based Code Generator API)

#### 7.2.1. 概念 (Concepts)

DataModel 提供了一个代码生成器，它接收一个**代码模板**，该模板通过特定的宏进行了增强，这些宏引用配置数据中的变量，从而生成代码。本节将介绍这种用于动态生成代码的宏语言。

模板语言不仅允许访问配置数据，还包括以下控制结构：

* `IF` (如果)
* `ELSE` (否则)
* `ELSEIF` (否则如果)
* `LOOP` (循环)
* `SELECT` (选择)
* `CALL` (调用)
* `VAR` (变量定义)
* `INCLUDE` (包含)

模板基于文本文件，可以生成任何基于文本的格式（C 代码、XML、HTML、文本等）。

命令与其周围的文本通过特殊的标记分隔：

* **命令起始标记**：`[!`
* **命令结束标记**：`!]`

**示例：**

```
[!IF "MyBoolean = 'true'"!]
   ...
[!ENDIF!]

```

如果需要在生成的输出中包含起始标记或结束标记本身，则必须对其进行转义。

* 起始标记 `[!` 转义为 `[\!`
* 结束标记 `!]` 转义为 `\!]`

#### 7.2.1.1. 使用 XPath 寻址节点 (Addressing nodes using XPath)

在模板中访问配置数据是通过 **XPath** 完成的。这是一种用于在 XML 文档（或在此处为 DataModel 树）中寻址部分的语言。有关 XPath 的详细介绍，请参见第 6.3 节 “XPath API”。

#### 7.2.1.2. 相同生成的生成文件 (Identical generated files)

如果生成器生成的文件的内容与磁盘上现有文件的内容相同，则该文件不会被覆盖。这意味着文件的时间戳不会改变。这对于使用 `make` 工具构建项目的环境非常重要，因为未更改的时间戳可以避免不必要的重新编译。

#### 7.2.2. 代码模板控制台 (Codetemplate console)

为了便于测试模板命令和 XPath 表达式，EB tresos Studio 提供了一个名为 **Codetemplate** 的视图。

要打开此视图，请在菜单中选择 **Window > Show View > Other... > Tresos > Codetemplate**。

*(图 7.2. 代码模板控制台视图)*

在该视图中，您可以输入模板代码并立即查看评估结果。这对于调试复杂的 XPath 表达式或测试模板逻辑非常有帮助。

* **Template** 区域：输入您的模板代码。
* **Result** 区域：显示生成的输出。
* **Context**：选择评估表达式时的上下文节点（通常是模块配置）。

#### 7.2.3. 注释 (Comments)

模板语言支持单行和多行注释。注释内容不会出现在生成的输出文件中。

* **单行注释**：使用 `//`。从 `//` 开始直到行尾的所有内容都会被忽略。
```
[!// 这是一个单行注释，不会出现在输出中]

```


* **多行注释**：使用 `/*` 和 `*/`。
```
[!/* 这是一个
     多行注释 */!]

```



#### 7.2.4. 评估变量和表达式 (Evaluating variables and expressions)

要评估变量或表达式并将结果插入到生成的文件中，可以使用以下语法：

```
[!"<XPath-Expression>"!]

```

生成器会计算 XPath 表达式，将其转换为字符串，并将其插入到输出流中。

**示例：**
假设配置中有一个名为 `BaudRate` 的整数参数，值为 `9600`。

```
BaudRate = [!"BaudRate"!]

```

**生成结果：**

```
BaudRate = 9600

```

#### 7.2.5. 包含其他文件 (Including other files)

可以使用 `INCLUDE` 命令将另一个模板文件的内容包含到当前模板中。这对于重用代码片段（如页眉、页脚或通用宏）非常有用。

**语法：**

```
[!INCLUDE "<Filename>"!]

```

* `<Filename>` 是相对于当前模板文件的路径，或者是相对于包含目录的路径。

#### 7.2.6. 条件 (Conditions)

可以使用 `IF`、`ELSEIF` 和 `ELSE` 结构来根据条件生成代码部分。

**语法：**

```
[!IF "<XPath-Condition>"!]
    ... (条件为真时生成的代码) ...
[!ELSEIF "<XPath-Condition>"!]
    ... (第一个条件为假且此条件为真时生成的代码) ...
[!ELSE!]
    ... (所有条件均为假时生成的代码) ...
[!ENDIF!]

```

* `<XPath-Condition>` 是一个评估结果为布尔值的 XPath 表达式。
* `ELSEIF` 和 `ELSE` 部分是可选的。

**示例：**

```
[!IF "EnableFeatureX = 'true'"!]
    #define FEATURE_X_ENABLED
[!ELSE!]
    #define FEATURE_X_DISABLED
[!ENDIF!]

```

#### 7.2.7. 循环和选择 (Loops and selects)

DataModel 是一个树状结构。为了遍历树中的节点（例如列表中的所有条目），可以使用 `LOOP` 命令。

**语法：**

```
[!LOOP "<XPath-NodeSet>"!]
    ... (对每个节点重复的代码) ...
[!ENDLOOP!]

```

* `<XPath-NodeSet>` 是一个返回节点集（Node-Set）的 XPath 表达式。
* 在循环体内部，**上下文节点**（Context Node，即 `.`）会变为当前正在遍历的节点。

**示例：**
遍历名为 `Channel` 的容器列表，并打印每个通道的 `Id`。

```
[!LOOP "Channel/*"!]
    Channel Id: [!"Id"!]
[!ENDLOOP!]

```

**SELECT 命令：**
`SELECT` 命令类似于 `LOOP`，但它不仅限于遍历，还可以用于改变当前的上下文节点，而不产生循环的语义（虽然技术上它也是遍历节点集）。它通常用于“进入”某个容器并在其中执行操作。

**语法：**

```
[!SELECT "<XPath-NodeSet>"!]
    ...
[!ENDSELECT!]

```

#### 7.2.8. 离开循环 (Leaving loops)

可以使用 `BREAK` 命令提前退出 `LOOP` 或 `SELECT` 块。

**语法：**

```
[!BREAK!]

```

通常结合 `IF` 使用：

```
[!LOOP "..."!]
    [!IF "Condition"!]
        [!BREAK!]
    [!ENDIF!]
    ...
[!ENDLOOP!]

```

#### 7.2.9. 变量和宏 (Variables and macros)

**变量 (Variables)**
您可以在模板中定义局部变量来存储临时结果。

* **定义/赋值变量**：
```
[!VAR "<Name>", "<Type>" = "<Value>"!]

```


或者简写（如果类型可推断）：
```
[!VAR "<Name>" = "<Value>"!]

```


* **访问变量**：
在 XPath 表达式中，使用 `var:<Name>` 来引用变量。

**示例：**

```
[!VAR "MyCounter" = "0"!]
[!LOOP "Channel/*"!]
    [!VAR "MyCounter" = "$MyCounter + 1"!]
[!ENDLOOP!]
Number of channels: [!"num:i($MyCounter)"!]

```

**宏 (Macros)**
宏允许您定义可重用的代码块。宏可以像函数一样被调用，并可以接收参数。

* **定义宏**：
```
[!MACRO "<Name>", "<Param1>", "<Param2>"!]
    ... (宏的内容) ...
[!ENDMACRO!]

```


* **调用宏**：
```
[!CALL "<Name>", "<Param1>" = "<Value1>", "<Param2>" = "<Value2>"!]

```



**示例：**

```
[!MACRO "PrintId", "Prefix"!]
    ID: [!"$Prefix"!]_[!"Id"!]
[!ENDMACRO!]

[!LOOP "Channel/*"!]
    [!CALL "PrintId", "Prefix" = "'CH'"!]
[!ENDLOOP!]

```

#### 7.2.10. 空格、换行和缩进 (Spaces, newlines and indentation)

代码生成器在处理空白字符（空格、制表符、换行符）时非常精确，这有时会导致生成的代码格式不符合预期（例如出现多余的空行）。

#### 7.2.10.1. 制表符 (Tab stops)

默认情况下，模板中的制表符会按原样输出。

#### 7.2.10.2. 空白字符 (Whitespaces)

默认情况下，命令标记（`[!...!`]）之外的所有字符（包括空格和换行）都会被输出。

#### 7.2.10.3. 换行符 (Newlines)

如果一行中只包含模板命令（例如 `[!IF...]`），该行末尾的换行符通常也会被保留，导致生成的代码中出现空行。

#### 7.2.10.4. 自动空格处理 (Auto-spacing)

为了解决格式问题，可以使用 `AUTOSPACING` 命令。

**语法：**

```
[!AUTOSPACING!]

```

当启用自动空格处理时，生成器会尝试智能地移除用于缩进模板命令的空白字符以及命令所在行的换行符，从而生成更紧凑、格式更好的代码。

> **注意：** `AUTOSPACING` 有一些限制和副作用（例如可能会意外删除需要的空格或在注释处理上表现不一致）。在使用时建议检查生成的输出。

#### 7.2.10.5. 缩进 (Indentation)

如果需要对生成的代码块进行统一缩进，可以使用 `INDENT` 命令。

**语法：**

```
[!INDENT "<Width>"!]
    ... (被缩进的内容) ...
[!ENDINDENT!]

```

* `<Width>` 是缩进的空格数。

**示例：**

```
void MyFunction(void)
{
[!INDENT "4"!]
    /* 这些行将被缩进 4 个空格 */
    DoSomething();
[!ENDINDENT!]
}

```

---

**（第 241-250 页翻译结束）**

接下来的内容（第 251 页起）将继续介绍：

* **7.2.11 排除文件 (Excluding files)**：如何根据条件阻止文件的生成。
* **7.2.12 断言、错误和警告**：如何在生成过程中向用户报告错误。
* **7.3 公共生成器 API (Public Generator API)**：如何使用 Java 接口实现生成器。

**是否继续翻译？**