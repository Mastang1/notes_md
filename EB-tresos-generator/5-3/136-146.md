这是文档 **第 136-146 页** 的翻译内容。

这一部分完成了 **变体处理 (Variant handling)** 的演示章节，介绍了如何通过 **多重配置容器 (Multiple Configuration Containers)** 支持构建后加载 (Post-build loadable)，并开启了关于 **配置模型 (Configuration models)** 的新篇章（第 6 章），深入讲解了 DataModel 的核心概念。

---

### 5.7.9.3. 代码生成器 (The code generators) (续)

存在一个通用的生成器变量 `postBuildVariant`，它存储当前构建的构建后变体 (post-build variant) 的短名称 (short-name)。

### 5.7.9.4. 切换变体 (Switching variants)

如果您切换可加载 (loadable) 或可选择 (selectable) 变体，配置会立即更改并显示所选变体的配置。

您可以在 EcuC 模块中切换可加载或可选择变体（见 5.7.9.1 节 “The EcuC module”）。此外，**快速访问 (Fast Access)** 工具栏提供了一种快速切换可选择变体的方法。

在图 5.13 “The Variant module (Variant2 selected)” 中，您可以看到当前选中的可选择变体是 `Variant2`。当您在通用编辑器中选择参数 `SelectableBoolean` 时，您会看到它被设置为 `true`。在 **Properties**（属性）视图中，您可以看到此参数的 `PostBuildVariantConditions`（构建后变体条件）：

*(图 5.15. SelectableBoolean 的属性)*

现在，您可以在快速访问工具栏中将选定的可选择变体更改为 `Variant1`。

*(图 5.16. 变体模块 (Variant1 selected))*

参数 `SelectableBoolean` 立即切换为 `false`，并且 Properties 视图显示分配的标准值 (criterion value) 为 0，这与 `Luxury`（豪华版）相关联。

### 5.7.9.5. 管理变体 (Managing variants)

在 **Sidebar**（侧边栏）视图的 **System** 类别下，存在两个向导：

* **Edit Loadable PostBuildVariants**：用于创建和管理可加载变体。
* **Edit Selectable PostBuildVariants**：用于创建和管理可选择变体。

这两个向导都包含两个标签页：

* **Predefined Variants (预定义变体)**：在此处管理预定义变体并将变体关联到标准 (criterions)。
* **Variant Criterions (变体标准)**：在此处管理构建后变体标准，并编辑标准的文本表示 (CompuMethod)。

当您从 Sidebar 视图打开 **Edit Selectable PostBuildVariants** 向导时，您可以看到可选择的预定义变体 `Variant2` 引用了值为 1 的 `PostBuildSelectableCriterion`，其文本表示为 “Poor mans car”。

*(图 5.17. Edit Selectable PostBuildVariants 向导的 Predefined Variants 标签页)*

当您切换到 **Variant Criterions** 标签页并从左侧表格中选择一个 `PostBuildVariantCriterion` 时，您可以管理所选标准的文本表示。

*(图 5.18. Edit Selectable PostBuildVariants 向导的 Variant Criterions 标签页)*

---

### 5.8. 通过多重配置容器支持构建后加载 (Post-build loadable support via Multiple Configuration Containers)

> **注意：多重配置容器支持自 AUTOSAR 4.2 起已弃用**
> AUTOSAR 4.2 通过新引入的配置类替换了多重配置容器支持。有关新概念的详细信息，请参阅 5.7.6 节 “将元素标记为构建后加载变体感知”。
> 尽管如此，EB tresos Studio 中仍然可以使用多重配置容器。

EB tresos Studio 内置支持 AUTOSAR 的 **多重配置容器 (Multiple Configuration Container, MCC)** 集方法，以实现构建后加载场景的兼容配置数据集变体。这包括对配置类为 `PostBuild` 的参数和引用，以及属性 `postBuildChangeable` 设置为 `true` 的容器的特殊处理。

有关标准的更多信息，请参阅 AUTOSAR 文档《ECU 配置规范》(Specification of ECU Configuration)。

EB tresos Studio 通过 **当前 MCC 集 (current MCC set)** 的概念扩展了 AUTOSAR 方法。有关 EB tresos Studio 中此概念的更多信息，请参阅 EB tresos Studio 用户指南中的 “使用多重配置容器的构建后加载配置” 一节。

#### 5.8.1. 提供构建后配置管理模块 (Providing a post-build configuration management module)

要启用 EB tresos Studio 的构建后加载配置支持，您需要提供对扩展点 `dreisoft.tresos.autosar2.api.plugin.multipleConfigurationContainerPostbuildSetup` 的贡献，例如在某些构建后配置管理模块 (PbcfgM) 插件中。

有了这些额外的元数据，EB tresos Studio 能够识别引用的模块配置的当前 MCC 集。如果用户实际配置了 PbcfgM 模块，EB tresos Studio 将在配置项目中的代码生成或数据导入等不同任务中使用这些当前 MCC。

在用户将配置项目切换到 **仅配置时构建后 (configuration time post-build only)** 模式后，EB tresos Studio 还会对模块配置数据应用更严格的约束。

有关更多信息和示例，请参阅扩展点描述。有关更多详细信息，请参阅 EB tresos Studio 用户指南中的 “使用多重配置容器的构建后加载配置” 一节。

#### 5.8.2. 关于启用构建后的配置模块的附加 VSMD 规则 (Additional VSMD rules regarding post-build enabled configuration modules)

为了验证您的启用构建后的供应商特定模块定义 (VSMD) 是否符合相关的 AUTOSAR 要求和约束，EB tresos Studio 提供了一个名为 `asc:4.0.3.RFCs` 的特殊规则集。

---

### 第 6 章：配置模型 (Configuration models)

#### 6.1. 概念：DataModel (The DataModel)

DataModel 提供了配置数据和其他信息的非常灵活的内存表示。在 EB tresos Studio 中，DataModel 用于表示 AUTOSAR 数据结构，但 DataModel 中包含的数据超出了此范围。

该模型主要分为三个部分：

* **Schematic-tree (Schema 树)**：包含有关所表示数据的元信息。在 AUTOSAR 上下文中，这类似于模块定义 (Module Definition)。
* **Data-tree (Data 树)**：包含配置值。对于每个 Data 节点，在 Schematic-tree 中都存在一个对应的节点。在 AUTOSAR 上下文中，这类似于模块配置 (Module Configuration)。
* **Preferences-tree (偏好设置树)**：存储既不与 Data 树也不与 Schema 树相关的其他一般信息。例如，项目的导入器设置存储在模型的这一部分中。Preferences-tree 不是官方 API。

> **注意：一个模型包含完整的 ECU 配置和定义**
> 在 EB tresos Studio 中，所有 AUTOSAR 模块配置及其模块定义都位于同一个模型中。这意味着您可以访问所有配置数据，甚至定义，而无需考虑您是从哪个模块访问该模型。

所有节点都存储在一个树结构中。因此，每个节点都有一个父节点和任意数量的子节点。只有树的顶层节点没有父节点。

*(图 6.1. 简单的节点树)*

配置数据存储在 **Data-tree** 中。此树的结构由 **Schematic-tree** 描述。Schema-tree 和 Data-tree 始终具有相同的结构，这意味着：

* 每个 Data 节点都有一个描述它的 Schema 节点。
* 每个 Data 节点都有一个指向描述它的 Schema 节点的引用。
* Data 节点的父节点指向对应 Schema 节点的父节点。它们之间永远不会有跳跃节点。这确保了 Schematic-tree 和 Data-tree 结构的相似性。

*(图 6.2. 简单的 Schematic-tree 和 Data-tree)*

Schematic-tree 和 Data-tree 由不同的节点类型表示：

| Schema | Data | 描述 |
| --- | --- | --- |
| **container-node** | **container-node** | 存储固定的节点列表。Schema 节点包含与 Data 节点相同数量的子节点。 |
| **list-node** | **list-node** | 存储可变的节点列表。Schema 节点始终只包含**一个**子节点。Data 节点为每个配置（添加）的值包含一个节点。 |
| **choice-node** | **choice-node** | 存储固定的节点列表。Schema 节点包含所有可用的选项作为子节点。Data 节点包含**所选的**节点作为子节点。 |
| **boolean-node**<br>

<br>**integer-node**<br>

<br>**string-node**<br>

<br>**float-node** | **variable-node** | Schema 节点描述 Data 节点的数据类型和范围。Data 节点存储一个配置条目。这些节点不能包含其他节点。 |
| **reference-node** | **reference-node** | Data 节点引用另一个节点。这些节点不能包含其他节点。 |

#### 6.1.1. Schematic-tree (Schema 树)

Schematic-tree 本身不存储任何配置数据。它只是描述 Data-tree 并提供有关以下的元信息：

* 配置数据变量的类型和范围
* 配置数据变量的默认值
* 可视组件的布局信息
* 工具提示 (tool-tip)
* 在线帮助
* 等

Data 节点的值作为字符串存储，没有进一步的类型信息。因此，只有在引用的 Schema 节点的元信息的支持下，才能正确解释 Data 节点的值。

**6.1.1.1. 示例**
下图中的四个 Data 节点持有相同的字符串值。在 Schema 节点的支持下，这些值获得了它们的数据类型：整数、浮点数、字符串和无效整数（像 RANGE 这样的属性将在 5.1 节 “概念：XDM 格式” 中解释）。

*(图 6.3. Schema 和 Data 中的节点)*

**6.1.1.2. Schema 节点的特性**
Schema 节点允许：

* 自动实例化相应的配置 Data 节点
* 填充默认值
* 验证输入的数据
* 渲染允许用户填写配置的对话框。

多个 Data-tree 可以引用同一个 Schema-tree，因为 Schema-tree 仅保存对于所有 Data-tree 都是唯一的元信息。

*(图 6.4. 多个 Data-tree 引用一个 Schematic-tree)*

#### 6.1.2. Data-Tree (Data 树)

Data 节点存储配置的值。对于 Schema-tree 中的每个节点，可以在 Data-tree 中创建相应的 Data 节点。

#### 6.1.3. Node-Attributes (节点属性)

每个节点可以有多个属性。每个属性可以存储多个字符串值，并按名称引用。

*(图 6.5. 节点和属性)*

例如，`DEFAULT` 属性保存 Data 节点的默认值。`RANGE` 属性可能包含定义 Data 节点范围的多个值。

当从 XDM 文件加载 Schema 或配置数据时，属性是按 XDM 文件中的定义显式设置的。当加载 AUTOSAR 配置格式时，属性是隐式设置的（例如，`RANGE` 属性将从 `ENUM-LITERAL-DEF` 计算得出）。

DataModel 识别两种类型的属性：

* **被动属性 (Passive attributes)**：值被显式设置。
* **自动属性 (Automatic attributes)**：它们的值将在每次树中的数据更改时计算，因为它们的值取决于当前配置。它们的值不能显式设置。

#### 6.1.4. DataModel 中的列表表示 (List-Representation within the DataModel)

列表节点 (list-node) 的一个特点是 Data 中的子节点可能比 Schema 中的多。在 Schema-tree 中，一个 list-node 始终**恰好有一个**子节点。这个子节点描述了 Data-tree 中相应 list-node 的子节点。Data-tree 中的所有列表子节点都引用 Schema-tree 中的那个单一列表子节点。

*(图 6.6. 列表表示)*

#### 6.1.5. DataModel 中的选择表示 (Choice-representation within the DataModel)

选择 (Choice) 提供了从子节点列表中选择单个节点的可能性。

* 在 **Schema-tree** 中，所有可用的节点都是 choice-node 的子节点。
* 在 **Data-tree** 中，choice 包含一个代表**用户所选节点**的子节点。Data 中的 choice-node 提供所选节点的名称作为节点值。

*(图 6.7. 选择表示)*

---

**（第 136-146 页翻译结束）**

接下来的内容（6.2 节起）将介绍：

* **6.2 如何在 XDM 文件中添加 GUI 注释**：包括通用配置编辑器的布局、模块 GUI 配置以及各种 GUI 元素（如复选框、文本框、组合框等）的详细 XML 属性配置。

**需要继续翻译吗？**